// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import {Script, stdJson, console} from "forge-std/Script.sol";

// These imports get generated by npm run generate:interfaces
import {StakeManager} from "../../helpers/interfaces/StakeManager.generated.sol";
import {StakeManagerProxy} from "../../helpers/interfaces/StakeManagerProxy.generated.sol";
import {ValidatorShare} from "../../helpers/interfaces/ValidatorShare.generated.sol";
import {Registry} from "../../helpers/interfaces/Registry.generated.sol";
import {Governance} from "../../helpers/interfaces/Governance.generated.sol";
import {WithdrawManager} from "../../helpers/interfaces/WithdrawManager.generated.sol";
import {WithdrawManagerProxy} from "../../helpers/interfaces/WithdrawManagerProxy.generated.sol";
import {ERC20} from "../../helpers/interfaces/ERC20.generated.sol";

import {Timelock} from "../../../contracts/common/misc/ITimelock.sol";

contract UpgradeMPTMainnet is Script {
    using stdJson for string;

    Timelock timelock;
    Registry registry;
    StakeManager stakeManagerProxy;
    Governance governance;
    WithdrawManager withdrawManagerProxy;
    address gSafeAddress;

    function run() public {
        uint256 deployerPrivateKey = vm.promptSecretUint("Enter deployer private key: ");
        //uint256 deployerPrivateKey = vm.envUint("PRIVATE_KEY");

        loadConfig();
        (StakeManager stakeManagerImpl, ValidatorShare validatorShareImpl, WithdrawManager withdrawManagerImpl) = deployImplementations(deployerPrivateKey);
        (bytes memory scheduleBatchPayload, bytes memory executeBatchPayload, bytes32 payloadId) =
            createPayload(stakeManagerImpl, validatorShareImpl, withdrawManagerImpl);

        console.log("Expected batch ID: %s", vm.toString(payloadId));

        console.log("\n----------------------\n");

        console.log("Send scheduleBatchPayload to: ", address(timelock));
        console.logBytes(scheduleBatchPayload);

        console.log("\n----------------------\n");

        console.log("Send executeBatchPayload to: ", address(timelock));
        console.logBytes(executeBatchPayload);
    }

    function loadConfig() public {
        console.log("Loading config \n");

        string memory input = vm.readFile("scripts/deployers/mpt-fix/input.json");
        string memory chainIdSlug = string(abi.encodePacked('["', vm.toString(block.chainid), '"]'));

        registry = Registry(input.readAddress(string.concat(chainIdSlug, ".registry")));
        stakeManagerProxy = StakeManager(input.readAddress(string.concat(chainIdSlug, ".stakeManagerProxy")));
        governance = Governance(input.readAddress(string.concat(chainIdSlug, ".governance")));
        timelock = Timelock(payable(input.readAddress(string.concat(chainIdSlug, ".timelock"))));
        withdrawManagerProxy = WithdrawManager(payable(input.readAddress(string.concat(chainIdSlug, ".withdrawManagerProxy"))));
        gSafeAddress = input.readAddress(string.concat(chainIdSlug, ".gSafe"));

        console.log("using Registry at: ", address(registry));
        console.log("using StakeManagerProxy at: ", address(stakeManagerProxy));
        console.log("using Governance at: ", address(governance));
        console.log("using Timelock at: ", address(timelock));
        console.log("using WithdrawManagerProxy at: ", address(withdrawManagerProxy));
        console.log("using gSafe at: ", gSafeAddress);
    }

    function deployImplementations(uint256 deployerPrivateKey)
        public
        returns (StakeManager stakeManagerImpl, ValidatorShare validatorShareImpl, WithdrawManager withdrawManagerImpl)
    {
        vm.startBroadcast(deployerPrivateKey);

        // deploy STEP 1
        // deploy new StakeManager version
        stakeManagerImpl = StakeManager(deployCode("out/StakeManager.sol/StakeManager.json"));

        console.log("deployed StakeManager implementation at: ", address(stakeManagerImpl));

        // deploy STEP 2
        // deploy new ValidatorShare version
        validatorShareImpl = ValidatorShare(deployCode("out/ValidatorShare.sol/ValidatorShare.json"));

        console.log("deployed ValidatorShare implementation at: ", address(validatorShareImpl));

        // deploy STEP 3
        // deploy new WithdrawManager version
        withdrawManagerImpl = WithdrawManager(payable(deployCode("out/WithdrawManager.sol/WithdrawManager.json")));

        console.log("deployed WithdrawManager implementation at: ", address(withdrawManagerImpl));

        vm.stopBroadcast();
    }

    function createPayload(StakeManager stakeManagerImpl, ValidatorShare validatorShareImpl, WithdrawManager withdrawManagerImpl)
        public
        view
        returns (bytes memory scheduleBatchPayload, bytes memory executeBatchPayload, bytes32 payloadId)
    {
        console.log("----------------------");
        console.log("Generating payloads \n");

        // STEP 1
        // Update ValidatorShare registry entry
        bytes memory payloadRegistry1 = abi.encodeCall(
            Governance.update, (address(registry), abi.encodeCall(Registry.updateContractMap, (keccak256("validatorShare"), address(validatorShareImpl))))
        );

        console.log("Created payloadRegistry1 for: ", address(governance));
        console.logBytes(payloadRegistry1);

        // STEP 2
        // Update StakeManagerProxy implementation contract
        bytes memory payloadStakeManager2 = abi.encodeCall(StakeManagerProxy.updateImplementation, (address(stakeManagerImpl)));

        console.log("Created payloadStakeManager2 for: ", address(stakeManagerProxy));
        console.logBytes(payloadStakeManager2);

        // STEP 3
        // update impl of proxy to WithdrawManager
        bytes memory payloadUpgradeWithdrawManager3 = abi.encodeCall(WithdrawManagerProxy.updateImplementation, (address(withdrawManagerImpl)));

        console.log("Created payloadUpgradeWithdrawManager3 for: ", address(withdrawManagerProxy));
        console.logBytes(payloadUpgradeWithdrawManager3);

        console.log("----------------------");
        console.log("Batching payloads \n");

        address[] memory targets = new address[](3);
        targets[0] = address(governance);
        targets[1] = address(stakeManagerProxy);
        targets[2] = address(withdrawManagerProxy);

        // Inits to 0
        uint256[] memory values = new uint256[](3);

        bytes[] memory payloads = new bytes[](9);
        payloads[0] = payloadRegistry1;
        payloads[1] = payloadStakeManager2;
        payloads[2] = payloadUpgradeWithdrawManager3;

        payloadId = timelock.hashOperationBatch(targets, values, payloads, "", "");

        scheduleBatchPayload = abi.encodeCall(Timelock.scheduleBatch, (targets, values, payloads, "", "", 0));
        executeBatchPayload = abi.encodeCall(Timelock.executeBatch, (targets, values, payloads, "", ""));
    }
}
