pragma solidity ^0.8.4;

// These imports get generated by npm run generate:interfaces
import {StakeManager} from "../../scripts/helpers/interfaces/StakeManager.generated.sol";
import {StakeManagerProxy} from "../../scripts/helpers/interfaces/StakeManagerProxy.generated.sol";
import {ValidatorShare} from "../../scripts/helpers/interfaces/ValidatorShare.generated.sol";
import {DepositManager} from "../../scripts/helpers/interfaces/DepositManager.generated.sol";
import {Registry} from "../../scripts/helpers/interfaces/Registry.generated.sol";
import {Proxy} from "../../scripts/helpers/interfaces/Proxy.generated.sol";

import {Timelock} from "../../contracts/common/misc/ITimelock.sol";

import "forge-std/Test.sol";

import {RevertPolUpgrade_Mainnet} from "../../scripts/deployers/revert-pol-upgrade/RevertPolUpgrade_mainnet.s.sol";

// @dev this test is written before the upgrade, so we perform the upgrade & then test the revert script
contract RevertPolUpgradePrePolUpgrade is Test, RevertPolUpgrade_Mainnet {
    uint256 mainnetForkPrePolUpgrade;

    function setUp() public {
        mainnetForkPrePolUpgrade = vm.createFork(vm.rpcUrl("mainnet"), 20671844);
        vm.selectFork(mainnetForkPrePolUpgrade);

        // perform pol-upgrade
        Vm.Wallet memory wallet = vm.createWallet("fork wallet");

        loadConfig(); // both inherits use the same config
        (
            StakeManager stakeManagerImpl,
            ValidatorShare validatorShareImpl,
            DepositManager depositManagerImpl
        ) = deployImplementations(wallet.privateKey);
        (bytes memory scheduleBatchPayload, bytes memory executeBatchPayload, bytes32 payloadId) = createPayload(
            stakeManagerImpl,
            validatorShareImpl,
            depositManagerImpl
        ); // is PolUpgrade.createPayload

        uint256 balanceStakeManager = maticToken.balanceOf(address(stakeManagerProxy));
        console.log("Initial StakeManager Matic balance: ", balanceStakeManager);
        assertNotEq(balanceStakeManager, 0);
        uint256 balanceDepositManager = maticToken.balanceOf(address(depositManagerProxy));
        console.log("Initial DepositManager Matic balance: ", balanceDepositManager);
        assertNotEq(balanceDepositManager, 0);

        vm.prank(gSafeAddress);
        (bool successSchedule, bytes memory dataSchedule) = address(timelock).call(scheduleBatchPayload);
        if (successSchedule == false) {
            assembly {
                revert(add(dataSchedule, 32), mload(dataSchedule))
            }
        }

        assertEq(successSchedule, true);
        assertEq(timelock.isOperation(payloadId), true);
        assertEq(timelock.isOperationPending(payloadId), true);

        vm.warp(block.timestamp + 172_800);

        assertEq(timelock.isOperationReady(payloadId), true);

        vm.prank(gSafeAddress);

        (bool successExecute, bytes memory dataExecute) = address(timelock).call(executeBatchPayload);
        if (successExecute == false) {
            assembly {
                revert(add(dataExecute, 32), mload(dataExecute))
            }
        }
        assertEq(successExecute, true);
        assertEq(timelock.isOperationDone(payloadId), true);

        // Check migrations happened
        assertEq(maticToken.balanceOf(address(stakeManagerProxy)), 0);
        assertEq(polToken.balanceOf(address(stakeManagerProxy)), balanceStakeManager);
        assertEq(maticToken.balanceOf(address(depositManagerProxy)), 0);
        assertEq(polToken.balanceOf(address(depositManagerProxy)), balanceDepositManager);

        // Check Registry values
        assertEq(registry.contractMap(keccak256("validatorShare")), address(validatorShareImpl));
        assertEq(registry.contractMap(keccak256("pol")), address(polToken));
        assertEq(registry.contractMap(keccak256("matic")), address(maticToken));
        assertEq(registry.contractMap(keccak256("polygonMigration")), migrationAddress);
        assertEq(registry.rootToChildToken(address(polToken)), nativeGasTokenAddress);
        assertEq(registry.childToRootToken(nativeGasTokenAddress), address(polToken));
        assertEq(registry.isERC721(address(polToken)), false);

        // Check Proxy implementation addresses
        assertEq(Proxy(payable(address(stakeManagerProxy))).implementation(), address(stakeManagerImpl));
        assertEq(Proxy(payable(address(depositManagerProxy))).implementation(), address(depositManagerImpl));

        _labelBefore();
    }

    function test_RevertPolUpgrade() public {
        // pol upgrade basic checks
        assertEq(maticToken.balanceOf(address(stakeManagerProxy)), 0);
        assertEq(maticToken.balanceOf(address(depositManagerProxy)), 0);
        assertNotEq(registry.contractMap(keccak256("validatorShare")), address(validatorShareLegacyImpl));

        uint256 smPolBalance = polToken.balanceOf(address(stakeManagerProxy));
        uint256 dmPolBalance = polToken.balanceOf(address(depositManagerProxy));

        // perform pre-requisistes for revert-pol-upgrade
        (
            StakeManager stakeManagerUnmigrateImpl,
            DepositManager depositManagerUnmigrateImpl
        ) = deployTemporaryUnmigrateImplementations(vm.createWallet("deployer").privateKey);
        _labelAfter(stakeManagerUnmigrateImpl, depositManagerUnmigrateImpl);

        (bytes memory scheduleBatchPayload, bytes memory executeBatchPayload, bytes32 payloadId) = createPayload(
            stakeManagerUnmigrateImpl,
            depositManagerUnmigrateImpl
        );

        _submitPayload(scheduleBatchPayload, executeBatchPayload, payloadId, 0);

        // #1
        assertEq(registry.contractMap(keccak256("validatorShare")), address(validatorShareLegacyImpl));

        // #2 & $3
        assertEq(polToken.balanceOf(address(stakeManagerProxy)), 0);
        assertEq(polToken.balanceOf(address(depositManagerProxy)), 0);

        assertEq(maticToken.balanceOf(address(stakeManagerProxy)), smPolBalance);
        assertEq(maticToken.balanceOf(address(depositManagerProxy)), dmPolBalance);

        assertEq(Proxy(payable(address(stakeManagerProxy))).implementation(), address(stakeManagerLegacyImpl));
        assertEq(Proxy(payable(address(depositManagerProxy))).implementation(), address(depositManagerLegacyImpl));
    }

    // function _expectCalls() internal {
    //     vm.expectCall(address())
    // }

    function _submitPayload(
        bytes memory _scheduleBatchPayload,
        bytes memory _executeBatchPayload,
        bytes32 _payloadId,
        uint256 _delay
    ) internal {
        vm.prank(gSafeAddress);
        (bool successSchedule, bytes memory dataSchedule) = address(timelock).call(_scheduleBatchPayload);
        assertTrue(successSchedule);

        assertEq(timelock.isOperation(_payloadId), true);
        assertEq(timelock.isOperationPending(_payloadId), true);

        vm.warp(block.timestamp + _delay);

        assertEq(timelock.isOperationReady(_payloadId), true);

        vm.prank(gSafeAddress);
        (bool successExecute, bytes memory dataExecute) = address(timelock).call(_executeBatchPayload);
        assertTrue(successExecute);
        assertEq(timelock.isOperationDone(_payloadId), true);
    }

    function _labelBefore() internal {
        vm.label(address(registry), "Registry");
        vm.label(address(stakeManagerProxy), "StakeManagerProxy");
        vm.label(address(governance), "Governance");
        vm.label(address(timelock), "Timelock");
        vm.label(address(depositManagerProxy), "DepositManagerProxy");
        vm.label(address(maticToken), "Matic");
        vm.label(address(polToken), "POL");
        vm.label(migrationAddress, "PolygonMigration");
        vm.label(nativeGasTokenAddress, "NativGasToken");
        vm.label(gSafeAddress, "gSafe");
    }

    function _labelAfter(StakeManager stakeManagerUnmigrateImpl, DepositManager depositManagerUnmigrateImpl) internal {
        vm.label(stakeManagerLegacyImpl, "stakeManagerLegacyImpl");
        vm.label(validatorShareLegacyImpl, "validatorShareLegacyImpl");
        vm.label(depositManagerLegacyImpl, "depositManagerLegacyImpl");

        vm.label(address(stakeManagerUnmigrateImpl), "stakeManagerUnmigrateImpl");
        vm.label(address(depositManagerUnmigrateImpl), "depositManagerUnmigrateImpl");
    }
}
