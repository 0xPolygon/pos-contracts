pragma solidity ^0.8.4;

// These imports get generated by npm run generate:interfaces
import {WithdrawManagerProxy} from "../../scripts/helpers/interfaces/WithdrawManagerProxy.generated.sol";
import {WithdrawManager} from "../../scripts/helpers/interfaces/WithdrawManager.generated.sol";
import {ValidatorShare} from "../../scripts/helpers/interfaces/ValidatorShare.generated.sol";
import {DepositManager} from "../../scripts/helpers/interfaces/DepositManager.generated.sol";
import {Registry} from "../../scripts/helpers/interfaces/Registry.generated.sol";
import {ERC20} from "../../scripts/helpers/interfaces/ERC20.generated.sol";
import {Proxy} from "../../scripts/helpers/interfaces/Proxy.generated.sol";

import {Timelock} from "../../contracts/common/misc/ITimelock.sol";

import "forge-std/Test.sol";

struct TxObject {
    uint256 block_number;
    address from;
    bytes input_proof;
    bytes modified_input_proof;
    bytes32 timestamp;
    address to;
    bytes32 transaction_hash;
    uint256 value;
}

struct FileObject {
    TxObject[] txObjects;
}

contract ForkupgradeMPT is Test {
    using stdJson for string;

    uint256 mainnetFork;

    function setUp() public {                             
        mainnetFork = vm.createFork(vm.rpcUrl("mainnet"), 20900000);
        vm.selectFork(mainnetFork);
    }

    function test_UpgradeMPT() public {
        assertEq(vm.activeFork(), mainnetFork);

        string memory input = vm.readFile("scripts/deployers/mpt-fix/input.json");
        string memory chainIdSlug = string(abi.encodePacked('["', vm.toString(block.chainid), '"]'));
        WithdrawManagerProxy withdrawManagerProxy = WithdrawManagerProxy(payable(input.readAddress(string.concat(chainIdSlug, ".withdrawManagerProxy"))));
        Timelock timelock = Timelock(payable(input.readAddress(string.concat(chainIdSlug, ".timelock"))));
        address exitNFT = input.readAddress(string.concat(chainIdSlug, ".exitNFT"));

        address withdrawManagerImpl = deployCode("out/WithdrawManager.sol/WithdrawManager.json");
       
        vm.prank(address(timelock));
        withdrawManagerProxy.updateImplementation(withdrawManagerImpl);
        WithdrawManager withdrawManager = WithdrawManager(payable(withdrawManagerProxy));

        // load tx to be replayed
        string memory txsJson = vm.readFile("test/foundry/batch1withdrawNew.json");
        bytes memory txs = vm.parseJson(txsJson);
        FileObject memory txBatch1 = abi.decode(txs, (FileObject));
        uint256 successes = 0;
        // loop
        for (uint i = 0; i < txBatch1.txObjects.length; i++) {
            console.log("tx num: ", i);
            TxObject memory obj = txBatch1.txObjects[i];
            console.log(obj.from);

            // Get the index of the exit
            uint256 index = withdrawManager.verifyInclusion(obj.modified_input_proof, 0, false);

            // Calculate the storage slots we need to manipulate to replay the tx
            bytes32 slotisKnownExit = keccak256(abi.encode(uint128(index << 1), 5));
            bytes32 slotexits = bytes32(uint256(keccak256(abi.encode(index << 1, 6)))+ 3);
            bytes32 slot_tokenOwner = keccak256(abi.encode((index << 1), 1));
            // WithdrawManager
            vm.store(address(withdrawManager), slotisKnownExit, 0);
            vm.store(address(withdrawManager), slotexits, 0);
            // ExitNFT
            vm.store(exitNFT, slot_tokenOwner, 0); 
            
         
            // Expect the exit correctly happens, this is the last thing that happens in an orderly exit
            vm.expectEmit(true, false, false, false, address(withdrawManager));
            emit WithdrawManager.ExitStarted(obj.from, index, address(0), 0, true);
            // Pretend to be the the exitor and replay tx
            vm.prank(obj.from);
            (bool successSchedule, bytes memory dataSchedule) = address(0x626fb210bf50e201ED62cA2705c16DE2a53DC966).call(obj.input_proof);
            if (successSchedule == false) {
                assembly {
                    revert(add(dataSchedule, 32), mload(dataSchedule))
                }
            } else {
                successes += 1;
                console.log("success");
            }
        }
        console.log("Total successful tx: ", successes);
    }
}
